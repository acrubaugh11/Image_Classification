# -*- coding: utf-8 -*-
"""Assignment1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RjxovLpt83rveFFtihWVUYFs0hUKquM5
"""

import cv2
import matplotlib.pyplot as plt

def display_images(image_paths):
    plt.figure(figsize=(13,5))
    for i, img in enumerate(images):
        plt.subplot(2, 3, i + 1)
        plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
        plt.axis('off')
    plt.show()

# load image paths using mounted drive
image_names = ['/content/drive/MyDrive/Images/image_0.jpg',
               '/content/drive/MyDrive/Images/image_1.jpg',
               '/content/drive/MyDrive/Images/image_2.jpg']
image_paths = [cv2.imread(name) for name in image_names]

# display images
display_images(images)

from PIL import Image
import numpy as np
import matplotlib.pyplot as plt



def display_rgb_channels(image_path):
    # open the image file
    img = Image.open(image_path).convert('RGB')

    # split the color channels for image
    b, g, r = img.split()


    # convert channels and display them as well as grayscale images
    b_array = np.array(b)
    g_array = np.array(g)
    r_array = np.array(r)

    # display
    plt.figure(figsize=(13, 5))

    # show B channel
    plt.subplot(1, 4, 1)
    plt.imshow(b_array, cmap='Blues')
    plt.title('Blue Channel')
    plt.axis('off')

    # show G channel
    plt.subplot(1, 4, 2)
    plt.imshow(g_array, cmap='Greens')
    plt.title('Green Channel')
    plt.axis('off')

    # show R channel
    plt.subplot(1, 4, 3)
    plt.imshow(r_array, cmap='Reds')
    plt.title('Red Channel')
    plt.axis('off')

    # grayscale image
    grayscale_img = img.convert('L')
    plt.subplot(1, 4, 4)
    plt.imshow(grayscale_img, cmap='gray')
    plt.title('Gray Image')
    plt.axis('off')


    plt.show()

image_0 = '/content/drive/MyDrive/Images/image_0.jpg'
image_1 = '/content/drive/MyDrive/Images/image_1.jpg'
image_2 = '/content/drive/MyDrive/Images/image_2.jpg'
display_rgb_channels(image_0)
display_rgb_channels(image_1)
display_rgb_channels(image_2)

from PIL import Image
import matplotlib.pyplot as plt



# function to get the grayscale of images
def get_grayscale_img(image_path):
    img = Image.open(image_path).convert('RGB')
    grayscale_img = img.convert('L')
    return grayscale_img

# function to resize images
def resize_image(img, new_height=256):
    # original width and height
    width, height = img.size

    # calculate original aspect ratio
    aspect_ratio = width / height

    # calculate and create new height and width
    updated_height = new_height
    updated_width = int(updated_height * aspect_ratio)

    # adjust for divisibility by 16
    updated_width = updated_width - (updated_width % 16)

    # resize image
    resized_image = img.resize((updated_width, updated_height))
    return resized_image


# image paths
image_0 = '/content/drive/MyDrive/Images/image_0.jpg'
image_1 = '/content/drive/MyDrive/Images/image_1.jpg'
image_2 = '/content/drive/MyDrive/Images/image_2.jpg'

# convert images to greyscale
grayscale_image0 = get_grayscale_img(image_0)
grayscale_image1 = get_grayscale_img(image_1)
grayscale_image2 = get_grayscale_img(image_2)

# resize greyscale images
resized_image0 = resize_image(grayscale_image0)
resized_image1 = resize_image(grayscale_image1)
resized_image2 = resize_image(grayscale_image2)

# display resized greyscale images
plt.figure(figsize=(13, 5))

# displaying each resized greyscale image and showing their new dimensions
plt.subplot(1, 3, 1)
plt.imshow(resized_image0, cmap='gray')
plt.axis('on')
plt.title(f'Resized Grayscale Image 0\n{resized_image0.width}:{resized_image0.height}')

plt.subplot(1, 3, 2)
plt.imshow(resized_image1, cmap='gray')
plt.axis('on')
plt.title(f'Resized Grayscale Image 1\n{resized_image1.width}:{resized_image1.height}')

plt.subplot(1, 3, 3)
plt.imshow(resized_image2, cmap='gray')
plt.axis('on')
plt.title(f'Resized Grayscale Image 2\n{resized_image2.width}:{resized_image2.height}')

plt.show()

import cv2
import numpy as np
import pandas as pd


# function to convert images into 16x16 feature vectors
def image_to_feature_vectors(image, block_size=16):
    # get dimensions of image
    image = np.array(image)
    h, w = image.shape
    # hold feature vectors
    feature_vectors = []

    # loop through each image and iterate over verticle and horizontal dimensions
    for i in range(0, h, block_size):
        for j in range(0, w, block_size):
            # extract block of 16 pixels
            block = image[i:i+block_size, j:j+block_size]
            #flatten the block into 1d into a vector
            block_vector = block.flatten()
            # append to feature vectors list
            feature_vectors.append(block_vector)
    return np.array(feature_vectors)



resized_images = [
    resized_image0,
    resized_image1,
    resized_image2
]


feature_vectors = []
lables = []

# loop through images and process them
for label, image in enumerate(resized_images):
  feature_vector = image_to_feature_vectors(image)
  feature_vectors.append(feature_vector)
   # assign the label
  lables.extend([label] * feature_vector.shape[0])

 # flatten the list of feature vectors into a array
feature_vectors_array = np.vstack(feature_vectors)
# format the final data so that lables are the last column and can be seen easily
data = np.column_stack((feature_vectors_array, lables))

# convert to pandas data frame
df = pd.DataFrame(data)
csv_output_path = '/content/drive/MyDrive/feature_vectors.csv'
df.to_csv(csv_output_path, index=False)

print(df)

import cv2
import numpy as np
import pandas as pd


# function to create sliding window feature vector
def sliding_block_feature_vectors(image, block_size=16, step_size=1):
  #get dimensions of image
  image = np.array(image)
  h, w = image.shape
  #hold feature vectors
  feature_vectors = []

  # iterate using sliding window
  for i in range(0, h - block_size + 1, step_size):
        for j in range(0, w - block_size + 1, step_size):
            # extract block
            block = image[i:i + block_size, j:j + block_size]
            # flatten block to a vector
            block_vector = block.flatten()
            feature_vectors.append(block_vector)

  return np.array(feature_vectors)


resized_images = [
    resized_image0,
    resized_image1,
    resized_image2
]


feature_vectors2 = []
lables = []


# loop through images and process them
for label, image in enumerate(resized_images):
  feature_vector = sliding_block_feature_vectors(image)
  feature_vectors2.append(feature_vector)
   # assign the label
  lables.extend([label] * feature_vector.shape[0])

 # flatten the list of feature vectors into a array
feature_vectors_array = np.vstack(feature_vectors2)
# format the final data so that lables are the last column and can be seen easily
data = np.column_stack((feature_vectors_array, lables))

# convert to pandas data frame
df = pd.DataFrame(data)
csv_output_path = '/content/drive/MyDrive/sliding_feature_vectors.csv'
df.to_csv(csv_output_path, index=False)

print(df)

import pandas as pd
import matplotlib.pyplot as plt
import random


# read feature space
feature_vectors_data = pd.read_csv('/content/drive/MyDrive/feature_vectors.csv')
sliding_feature_vectors_data = pd.read_csv('/content/drive/MyDrive/sliding_feature_vectors.csv')

# printing the statistical information for each feature vecotr
print("feature vectors statistical data:")
print(feature_vectors_data.describe())

# printing the observations of each feature vector
print("sliding feature vectors statistical data: ")
print(sliding_feature_vectors_data.describe())

print(f"\nFeature vectors number of observations: {feature_vectors_data.shape[0]}")
print(f"\nSliding feature vectors number of observations: {sliding_feature_vectors_data.shape[0]}")

# function to make histograms for data sets
def plot_random_histograms(data, type_of_vector, num_features=5):
    data = data.drop(data.columns[-1], axis = 1)

    features = random.sample(range(0, 256), num_features)

    # Plot histograms for the selected random features
    plt.figure(figsize=(15, 7))
    data.iloc[:, features].hist(bins=20, figsize=(17, 9))
    plt.suptitle(type_of_vector)
    plt.show()

# Plot histograms for both datasets
plot_random_histograms(feature_vectors_data, 'feature vectors Histograms')
plot_random_histograms(sliding_feature_vectors_data, 'sliding feature vectors Histograms')

import pandas as pd
import matplotlib.pyplot as plt
import random


# read feature vectors
feature_vectors_data = pd.read_csv('/content/drive/MyDrive/feature_vectors.csv')
sliding_feature_vectors_data = pd.read_csv('/content/drive/MyDrive/sliding_feature_vectors.csv')
# count the distribution of labels
print("feature vectors distribution of labels:")
label_counts = feature_vectors_data.iloc[:, -1].value_counts()
print(label_counts)
# count the number of samples in the data set
total_samples = len(feature_vectors_data)
# get the size of majority and minority class and divide the two to get the imbalance ratio
max_label_counts = label_counts.max()
min_label_counts = label_counts.min()
imbalance_ratio = max_label_counts / min_label_counts if min_label_counts > 0 else None
print(f"Imbalance Ratio for feature vectors: {imbalance_ratio}")
# check the data set for any missing values to see if its incomplete
missing_values = feature_vectors_data.isnull().sum()
print("\nMissing Values:")
print(missing_values)
# check if the data is big data
num_rows, num_columns = feature_vectors_data.shape
print(f"\nNumber of rows: {num_rows}")
print(f"Number of columns: {num_columns}")
# check memory usage of the data
memory_usage = feature_vectors_data.memory_usage(deep=True).sum()
print(f"Memory usage of the dataset: {memory_usage / 1024 ** 2:.2f} MB")
# check high dimensionality by seeing if n < p or if observations are less than features
feature_vector_dimensionality = feature_vectors_data.shape[1] / feature_vectors_data.shape[0]
print(f"If n < p then feature vector is high dimensional. n / p = {feature_vector_dimensionality}")



# repeat for sliding feature vectors data set
print("\nsliding feature vectors distribution of labels:")
label_counts = sliding_feature_vectors_data.iloc[:, -1].value_counts()
print(label_counts)
total_samples = len(sliding_feature_vectors_data)
max_label_counts = label_counts.max()
min_label_counts = label_counts.min()
imbalance_ratio = max_label_counts / min_label_counts if min_label_counts > 0 else None
print(f"Imbalance Ratio for sliding feature vectors: {imbalance_ratio}")
missing_values = sliding_feature_vectors_data.isnull().sum()
print("\nMissing Values:")
print(missing_values)
num_rows, num_columns = sliding_feature_vectors_data.shape
print(f"\nNumber of rows: {num_rows}")
print(f"Number of columns: {num_columns}")
memory_usage = sliding_feature_vectors_data.memory_usage(deep=True).sum()
print(f"Memory usage of the dataset: {memory_usage / 1024 ** 2:.2f} MB")
feature_vector_dimensionality = sliding_feature_vectors_data.shape[1] / sliding_feature_vectors_data.shape[0]
print(f"If n < p then feature vector is high dimensional. n / p = {feature_vector_dimensionality}")

import pandas as pd
import matplotlib.pyplot as plt
import random


# read feature vectors
feature_vectors_data = pd.read_csv('/content/drive/MyDrive/feature_vectors.csv')
sliding_feature_vectors_data = pd.read_csv('/content/drive/MyDrive/sliding_feature_vectors.csv')

# get each individual images and their vector spaces by sorting via labels
image0_data = feature_vectors_data[feature_vectors_data.iloc[:, -1] == 0]
image1_data = feature_vectors_data[feature_vectors_data.iloc[:, -1] == 1]
image2_data = feature_vectors_data[feature_vectors_data.iloc[:, -1] == 2]

# read each image classes feature vectors into csv
image0_data.to_csv('/content/drive/MyDrive/image0.csv', index=False)
image1_data.to_csv('/content/drive/MyDrive/image1.csv', index=False)
image2_data.to_csv('/content/drive/MyDrive/image2.csv', index=False)

# read each images csv file
image0_data = pd.read_csv('/content/drive/MyDrive/image0.csv')
image1_data = pd.read_csv('/content/drive/MyDrive/image1.csv')
image2_data = pd.read_csv('/content/drive/MyDrive/image2.csv')

# merge feature vectors in image0.csv and image1.csv into image01.csv
image01_data = pd.concat([image0_data, image1_data], ignore_index=True)
# must randomize placement of rows of csv files
image01_data = image01_data.sample(frac=1).reset_index(drop=True)
# write to csv file
image01_data.to_csv('/content/drive/MyDrive/image01.csv', index=False)


# merge feature vectors in image0.csv, image1.csv, and image2.csv into image012.csv
image012_data = pd.concat([image0_data, image1_data, image2_data], ignore_index=True)
# randomize placement of rows of csv files
image012_data = image012_data.sample(frac=1).reset_index(drop=True)
# write to csv file
image012_data.to_csv('/content/drive/MyDrive/image012.csv', index=False)

# print the shapes
print("Image 01 shape:")
print(image01_data.shape)
print("Image 012 shape:")
print(image012_data.shape)


# get each individual images and their vector spaces by sorting via labels
image0_sliding_window_df = sliding_feature_vectors_data[sliding_feature_vectors_data.iloc[:, -1] == 0]
image1_sliding_window_df = sliding_feature_vectors_data[sliding_feature_vectors_data.iloc[:, -1] == 1]
image2_sliding_window_df = sliding_feature_vectors_data[sliding_feature_vectors_data.iloc[:, -1] == 2]

# save each image classes into csvs
image0_sliding_window_df.to_csv('/content/drive/MyDrive/image0_sliding_window.csv', index=False)
image1_sliding_window_df.to_csv('/content/drive/MyDrive/image1_sliding_window.csv', index=False)
image2_sliding_window_df.to_csv('/content/drive/MyDrive/image2_sliding_window.csv', index=False)

# read each images csv file
image0_sliding_window_df = pd.read_csv('/content/drive/MyDrive/image0_sliding_window.csv')
image1_sliding_window_df = pd.read_csv('/content/drive/MyDrive/image1_sliding_window.csv')
image2_sliding_window_df = pd.read_csv('/content/drive/MyDrive/image2_sliding_window.csv')

# merge feature vectors in image0.csv and image1.csv into image01_sliding_window.csv
image01_sliding_window_df = pd.concat([image0_sliding_window_df, image1_sliding_window_df], ignore_index=True)
# must randomize placement of rows of csv files
image01_sliding_window_df = image01_sliding_window_df.sample(frac=1).reset_index(drop=True)
# write to csv file
image01_sliding_window_df.to_csv('/content/drive/MyDrive/image01_sliding_window.csv', index=False)


# merge feature vectors in image0.csv, image1.csv, and image2.csv into image012_sliding_window.csv
image012_sliding_window_df = pd.concat([image0_sliding_window_df, image1_sliding_window_df, image2_sliding_window_df], ignore_index=True)
# randomize placement of rows of csv files
image012_sliding_window_df = image012_sliding_window_df.sample(frac=1).reset_index(drop=True)
# write to csv file
image012_sliding_window_df.to_csv('/content/drive/MyDrive/image012_sliding_window.csv', index=False)


# print the shapes
print("Image 01 sliding window shape:")
print(image01_sliding_window_df.shape)
print("Image 012 sliding window shape:")
print(image012_sliding_window_df.shape)

import pandas as pd
import matplotlib.pyplot as plt
import random


# load merged feature space data sets
image012_data = pd.read_csv('/content/drive/MyDrive/image012.csv')
image01_data = pd.read_csv('/content/drive/MyDrive/image01.csv')

# plot 2d feature space
def plot_2d_feature_space(data, feature_1, feature_2, title):
  plt.figure(figsize=(13, 7))
  # to extract the columns leaving out the label column
  features = data.iloc[:, :-1].values
  # the label column or class labels
  labels = data.iloc[:, -1].values
  # loop through each label value and create subsets to plot the 2d array of feature 1 and feature 2
  for label in set(labels):
    subset = data[data.iloc[:, -1] == label]
    plt.scatter(subset.iloc[:, feature_1], subset.iloc[:, feature_2], label=f'Class {label}', alpha=0.5)

  # plot the feature space
  plt.title(f'2D Feature Space: {title}')
  plt.xlabel(f'Feature {feature_1}')
  plt.ylabel(f'Feature {feature_2}')
  plt.legend()
  plt.show()


# plot 3d feature space
def plot_3d_feature_space(data, feature_1, feature_2, feature_3, title):
  plt.figure(figsize=(13, 7))
  # create 3d plot
  ax = plt.axes(projection='3d')

  # to extract the columns leaving out the label column
  features = data.iloc[:, :-1].values
  # the label column or class labels
  labels = data.iloc[:, -1].values
  # loop through each label value and create subsets to plot the 2d array of feature 1 and feature 2
  for label in set(labels):
    subset = data[data.iloc[:, -1] == label]
    ax.scatter(subset.iloc[:, feature_1], subset.iloc[:, feature_2], subset.iloc[:, feature_3],
               label=f'Class {label}', alpha=0.7)

  # plot the feature space
  ax.set_title(f'3D Feature Space: {title}')
  ax.set_xlabel(f'Feature {feature_1}')
  ax.set_ylabel(f'Feature {feature_2}')
  ax.set_zlabel(f'Feature {feature_3}')
  ax.legend()
  plt.show()

# plot 2D for for 2 classes in block feature vectors
plot_2d_feature_space(image01_data, 0, 1, 'Two Class Labels; Image0 & Image1')
plot_2d_feature_space(image01_sliding_window_df, 0, 1, 'Two Class Labels; Image0 & Image1 (Sliding Feature Vectors)')

# plot 3D for 3 classes in block feature vectors
plot_3d_feature_space(image012_data, 0, 1, 2, 'Three Class Labels; Image0, Image1, & Image2')
plot_3d_feature_space(image012_sliding_window_df, 0, 1, 2, 'Three Class Labels; Image0, Image1, & Image2 (Sliding Feature Vectors)')